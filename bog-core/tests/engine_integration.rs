//! Integration tests for the full tick-to-trade pipeline
//!
//! Tests that fills generated by the executor are properly processed by the position tracker
//! This is the critical integration that was previously missing.

use bog_core::engine::Engine;
use bog_core::engine::simulated::SimulatedExecutor;
use bog_core::core::Signal;
use huginn::MarketSnapshot;

// Test strategy that builds a long position
struct LongOnlyStrategy {
    tick_count: usize,
}

impl bog_core::engine::Strategy for LongOnlyStrategy {
    fn calculate(&mut self, _snapshot: &MarketSnapshot) -> Option<Signal> {
        self.tick_count += 1;
        
        // Only quote bid for first 5 ticks to build long position
        if self.tick_count <= 5 {
            Some(Signal::quote_bid(
                50_000_000_000_000, // bid_price: $50,000
                100_000_000,        // size: 0.1 BTC
            ))
        } else {
            // Then quote both to see position change
            Some(Signal::quote_both(
                50_000_000_000_000, // bid_price: $50,000
                50_002_000_000_000, // ask_price: $50,002
                100_000_000,        // size: 0.1 BTC
            ))
        }
    }
    
    fn name(&self) -> &'static str {
        "LongOnlyStrategy"
    }
}

fn create_test_snapshot(
    market_id: u64,
    sequence: u64,
    bid_price: u64,
    ask_price: u64,
    bid_size: u64,
    ask_size: u64,
) -> MarketSnapshot {
    MarketSnapshot {
        market_id,
        sequence,
        exchange_timestamp_ns: 0,
        local_recv_ns: 0,
        local_publish_ns: 0,
        best_bid_price: bid_price,
        best_bid_size: bid_size,
        best_ask_price: ask_price,
        best_ask_size: ask_size,
        bid_prices: [0; 10],
        bid_sizes: [0; 10],
        ask_prices: [0; 10],
        ask_sizes: [0; 10],
        snapshot_flags: 0,
        dex_type: 1,
        _padding: [0; 110],
    }
}

/// Test that position accumulates correctly across multiple ticks
#[test]
fn test_position_accumulates_across_ticks() {
    // Given: Engine with SimulatedExecutor and a strategy that builds long position
    let strategy = LongOnlyStrategy { tick_count: 0 };
    let executor = SimulatedExecutor::new(256, 1024);
    
    let mut engine = Engine::new(strategy, executor);
    
    // Simulate 10 ticks that should generate fills
    for i in 0..10 {
        let snapshot = create_test_snapshot(
            1, // market_id
            i as u64, // sequence
            50_000_000_000_000 + (i as u64 * 10_000_000_000), // bid_price
            50_002_000_000_000 + (i as u64 * 10_000_000_000), // ask_price
            1_000_000_000, // bid_size
            1_000_000_000, // ask_size
        );
        
        engine.process_tick(&snapshot).unwrap();
    }
    
    // Get position from engine
    let position = engine.position();
    
    // After 10 ticks with fills, position should be non-zero (buys = 5, sells = 5, so net should be around 0.5 BTC)
    // Actually: first 5 ticks: 1 buy each = +0.5 BTC
    // Next 5 ticks: 1 buy + 1 sell each = net 0, so total position should be +0.5 BTC
    let position_qty = position.get_quantity();
    assert!(position_qty > 0, "Position should be positive after building long. Position: {}", position_qty);
    assert!(position.get_trade_count() >= 15, "Should have recorded at least 15 trades");
}

/// Test that position can go long and short correctly
#[test]
fn test_position_long_and_short() {
    let strategy = LongOnlyStrategy { tick_count: 0 };
    let executor = SimulatedExecutor::new(256, 1024);
    
    let mut engine = Engine::new(strategy, executor);
    
    // First tick: should go long
    let snapshot1 = create_test_snapshot(
        1, 1, 
        50_000_000_000_000, 50_002_000_000_000,
        1_000_000_000, 1_000_000_000
    );
    
    engine.process_tick(&snapshot1).unwrap();
    let after_first = engine.position().get_quantity();
    
    // Second tick: opposite market conditions, might go short
    let snapshot2 = create_test_snapshot(
        1, 2,
        52_000_000_000_000, 52_002_000_000_000,
        1_000_000_000, 1_000_000_000
    );
    
    engine.process_tick(&snapshot2).unwrap();
    
    // Position should have changed
    let final_position = engine.position().get_quantity();
    assert!(final_position != after_first);
    assert!(engine.position().get_trade_count() >= 2);
}

/// Test high-frequency tick processing without crashes
#[test]
fn test_high_frequency_tick_processing() {
    use std::time::Instant;
    
    let strategy = LongOnlyStrategy { tick_count: 0 };
    let executor = SimulatedExecutor::new(256, 1024);
    
    let mut engine = Engine::new(strategy, executor);
    
    let start = Instant::now();
    
    // Process 1000 ticks rapidly
    for i in 0..1000 {
        let snapshot = create_test_snapshot(
            1, i as u64,
            50_000_000_000_000 + ((i % 100) as u64 * 10_000_000), // bid_price
            50_002_000_000_000 + ((i % 100) as u64 * 10_000_000), // ask_price
            1_000_000_000, // bid_size
            1_000_000_000, // ask_size
        );
        
        engine.process_tick(&snapshot).unwrap();
    }
    
    let duration = start.elapsed();
    
    // Should complete quickly (< 100ms)
    assert!(duration.as_millis() < 100);
    
    let position = engine.position();
    
    // Position should be tracked correctly
    assert!(position.get_trade_count() > 0);
    println!("Processed 1000 ticks in {:?}, position: {} satoshis, trades: {}", 
             duration, position.get_quantity(), position.get_trade_count());
}
