   Compiling huginn v0.1.0 (/Users/vegtam/code/huginn)
   Compiling bog-core v0.1.0 (/Users/vegtam/code/bog/bog-core)
warning: unexpected `cfg` condition value: `testing`
   --> bog-core/src/lib.rs:320:17
    |
320 | #[cfg(any(test, feature = "testing"))]
    |                 ^^^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `aggressive`, `conservative`, `default`, `inventory-based`, `live`, `market-1`, `market-2`, `max-daily-loss-100`, `max-daily-loss-1000`, `max-daily-loss-10000`, `max-order-half`, `max-order-one`, `max-order-tenth`, `max-position-five`, `max-position-half`, `max-position-one`, `max-short-five`, `max-short-half`, `max-short-one`, `metrics`, `min-order-centi`, `min-order-milli`, `min-order-tenth`, `simple-spread`, and `simulated`
    = help: consider adding `testing` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused variable: `pooled_fill`
   --> bog-core/src/engine/simulated.rs:292:24
    |
292 |         while let Some(pooled_fill) = self.pending_fills.pop() {
    |                        ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pooled_fill`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: variable does not need to be mutable
   --> bog-core/src/engine/simulated.rs:291:13
    |
291 |         let mut fills = Vec::new();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `metrics`
   --> bog-core/src/monitoring/alert_rules.rs:185:13
    |
185 |         let metrics = context.metrics.trading();
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_metrics`

warning: fields `order_id`, `price_level`, `our_size`, and `timestamp` are never read
  --> bog-core/src/execution/simulated.rs:70:5
   |
68 | struct QueuePosition {
   |        ------------- fields in this struct
69 |     /// Order ID
70 |     order_id: OrderId,
   |     ^^^^^^^^
71 |     /// Price level (u64 fixed-point)
72 |     price_level: u64,
   |     ^^^^^^^^^^^
73 |     /// Our order size
74 |     our_size: Decimal,
   |     ^^^^^^^^
...
79 |     timestamp: std::time::SystemTime,
   |     ^^^^^^^^^
   |
   = note: `QueuePosition` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: method `total_fill_volume` is never used
  --> bog-core/src/execution/production.rs:56:8
   |
37 | impl OrderState {
   | --------------- method in this implementation
...
56 |     fn total_fill_volume(&self) -> Decimal {
   |        ^^^^^^^^^^^^^^^^^

warning: method `record_prometheus_metrics` is never used
   --> bog-core/src/execution/production.rs:326:8
    |
267 | impl ProductionExecutor {
    | ----------------------- method in this implementation
...
326 |     fn record_prometheus_metrics(&self) {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: constant `QUEUE_DEPTH_WARNING_THRESHOLD` is never used
   --> bog-core/src/engine/generic.rs:222:7
    |
222 | const QUEUE_DEPTH_WARNING_THRESHOLD: usize = 100;
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: method `track_queue_depth` is never used
   --> bog-core/src/engine/generic.rs:285:8
    |
264 | impl<S: Strategy, E: Executor> Engine<S, E> {
    | ------------------------------------------- method in this implementation
...
285 |     fn track_queue_depth(&self, depth: usize) {
    |        ^^^^^^^^^^^^^^^^^

warning: field `first_seen` is never read
   --> bog-core/src/monitoring/alerts.rs:190:5
    |
188 | struct AlertState {
    |        ---------- field in this struct
189 |     /// First occurrence timestamp
190 |     first_seen: SystemTime,
    |     ^^^^^^^^^^
    |
    = note: `AlertState` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

   Compiling bog-strategies v0.1.0 (/Users/vegtam/code/bog/bog-strategies)
warning: variable does not need to be mutable
   --> bog-strategies/src/simple_spread.rs:597:14
    |
597 |         let (mut our_bid, mut our_ask) = Self::calculate_quotes(mid_price);
    |              ----^^^^^^^
    |              |
    |              help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
   --> bog-strategies/src/simple_spread.rs:597:27
    |
597 |         let (mut our_bid, mut our_ask) = Self::calculate_quotes(mid_price);
    |                           ----^^^^^^^
    |                           |
    |                           help: remove this `mut`

   Compiling bog-bins v0.1.0 (/Users/vegtam/code/bog/bog-bins)
warning: `bog-strategies` (lib) generated 2 warnings (run `cargo fix --lib -p bog-strategies` to apply 2 suggestions)
warning: `bog-core` (lib) generated 10 warnings (run `cargo fix --lib -p bog-core` to apply 1 suggestion)
   Compiling bog-debug v0.1.0 (/Users/vegtam/code/bog/bog-debug)
warning: unused import: `tracing::info`
  --> bog-debug/src/bin/orderbook_tui.rs:44:5
   |
44 | use tracing::info;
   |     ^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused variable: `app`
   --> bog-debug/src/bin/orderbook_tui.rs:373:45
    |
373 | fn render_footer(f: &mut Frame, area: Rect, app: &App) {
    |                                             ^^^ help: if this is intentional, prefix it with an underscore: `_app`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: comparison is useless due to type limits
    --> bog-strategies/src/simple_spread.rs:1477:17
     |
1477 |         assert!(bid_level >= 0 && bid_level <= 3, "Should select a valid level");
     |                 ^^^^^^^^^^^^^^
     |
     = note: `#[warn(unused_comparisons)]` on by default

warning: comparison is useless due to type limits
    --> bog-strategies/src/simple_spread.rs:1518:17
     |
1518 |         assert!(bid_level >= 0 && bid_level < 3);
     |                 ^^^^^^^^^^^^^^

warning: unused import: `SignalAction`
   --> bog-core/src/engine/generic.rs:690:31
    |
690 |     use crate::core::{Signal, SignalAction};
    |                               ^^^^^^^^^^^^
    |
    = note: `#[warn(unused_imports)]` on by default

error[E0046]: not all trait items implemented, missing: `get_fills`, `dropped_fill_count`
   --> bog-core/src/engine/generic.rs:717:5
    |
157 |     fn get_fills(&mut self) -> Vec<crate::execution::Fill>;
    |     ------------------------------------------------------- `get_fills` from trait
...
163 |     fn dropped_fill_count(&self) -> u64;
    |     ------------------------------------ `dropped_fill_count` from trait
...
717 |     impl Executor for MockExecutor {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `get_fills`, `dropped_fill_count` in implementation

error[E0308]: mismatched types
   --> bog-core/src/core/order_fsm.rs:901:13
    |
900 |         let order = match result {
    |                           ------ this expression has type `order_fsm::FillResultOrError`
901 |             FillResult::PartiallyFilled(o) => o,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FillResultOrError`, found `FillResult`
    |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
    |
901 |             core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(o)) => o,
    |             +++++++++++++++++++++++++++++++++++++++                              +

error[E0599]: no method named `is_filled` found for enum `PartialFillResultOrError` in the current scope
   --> bog-core/src/core/order_fsm.rs:910:24
    |
146 | pub enum PartialFillResultOrError {
    | --------------------------------- method `is_filled` not found for this enum
...
910 |         assert!(result.is_filled());
    |                        ^^^^^^^^^ method not found in `PartialFillResultOrError`
    |
note: the method `is_filled` exists on the type `order_fsm::FillResult`
   --> bog-core/src/core/order_fsm.rs:686:5
    |
686 |     pub fn is_filled(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> bog-core/src/core/order_fsm.rs:911:16
    |
911 |         if let FillResult::Filled(order) = result {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `PartialFillResultOrError`
    |                |
    |                expected `PartialFillResultOrError`, found `FillResult`
    |
help: try wrapping the pattern in `core::order_fsm::PartialFillResultOrError::Ok`
    |
911 |         if let core::order_fsm::PartialFillResultOrError::Ok(FillResult::Filled(order)) = result {
    |                ++++++++++++++++++++++++++++++++++++++++++++++                         +

error[E0308]: mismatched types
   --> bog-core/src/core/order_fsm.rs:924:13
    |
923 |         let order = match result {
    |                           ------ this expression has type `order_fsm::FillResultOrError`
924 |             FillResult::PartiallyFilled(o) => o,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FillResultOrError`, found `FillResult`
    |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
    |
924 |             core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(o)) => o,
    |             +++++++++++++++++++++++++++++++++++++++                              +

error[E0599]: no method named `is_partially_filled` found for enum `PartialFillResultOrError` in the current scope
   --> bog-core/src/core/order_fsm.rs:931:24
    |
146 | pub enum PartialFillResultOrError {
    | --------------------------------- method `is_partially_filled` not found for this enum
...
931 |         assert!(result.is_partially_filled());
    |                        ^^^^^^^^^^^^^^^^^^^ method not found in `PartialFillResultOrError`
    |
note: the method `is_partially_filled` exists on the type `order_fsm::FillResult`
   --> bog-core/src/core/order_fsm.rs:691:5
    |
691 |     pub fn is_partially_filled(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> bog-core/src/core/order_fsm.rs:932:16
    |
932 |         if let FillResult::PartiallyFilled(order) = result {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `PartialFillResultOrError`
    |                |
    |                expected `PartialFillResultOrError`, found `FillResult`
    |
help: try wrapping the pattern in `core::order_fsm::PartialFillResultOrError::Ok`
    |
932 |         if let core::order_fsm::PartialFillResultOrError::Ok(FillResult::PartiallyFilled(order)) = result {
    |                ++++++++++++++++++++++++++++++++++++++++++++++                                  +

error[E0308]: mismatched types
   --> bog-core/src/core/order_fsm.rs:956:13
    |
955 |         let order = match result {
    |                           ------ this expression has type `order_fsm::FillResultOrError`
956 |             FillResult::PartiallyFilled(o) => o,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FillResultOrError`, found `FillResult`
    |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
    |
956 |             core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(o)) => o,
    |             +++++++++++++++++++++++++++++++++++++++                              +

error[E0599]: no method named `is_filled` found for enum `order_fsm::FillResultOrError` in the current scope
   --> bog-core/src/core/order_fsm.rs:988:24
    |
126 | pub enum FillResultOrError {
    | -------------------------- method `is_filled` not found for this enum
...
988 |         assert!(result.is_filled());
    |                        ^^^^^^^^^ method not found in `order_fsm::FillResultOrError`
    |
note: the method `is_filled` exists on the type `order_fsm::FillResult`
   --> bog-core/src/core/order_fsm.rs:686:5
    |
686 |     pub fn is_filled(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> bog-core/src/core/order_fsm.rs:989:16
    |
989 |         if let FillResult::Filled(order) = result {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `order_fsm::FillResultOrError`
    |                |
    |                expected `FillResultOrError`, found `FillResult`
    |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
    |
989 |         if let core::order_fsm::FillResultOrError::Ok(FillResult::Filled(order)) = result {
    |                +++++++++++++++++++++++++++++++++++++++                         +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1001:13
     |
1000 |         let order = match result {
     |                           ------ this expression has type `order_fsm::FillResultOrError`
1001 |             FillResult::PartiallyFilled(o) => o,
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
     |
1001 |             core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(o)) => o,
     |             +++++++++++++++++++++++++++++++++++++++                              +

error[E0599]: no method named `is_filled` found for enum `PartialFillResultOrError` in the current scope
    --> bog-core/src/core/order_fsm.rs:1008:24
     |
 146 | pub enum PartialFillResultOrError {
     | --------------------------------- method `is_filled` not found for this enum
...
1008 |         assert!(result.is_filled());
     |                        ^^^^^^^^^ method not found in `PartialFillResultOrError`
     |
note: the method `is_filled` exists on the type `order_fsm::FillResult`
    --> bog-core/src/core/order_fsm.rs:686:5
     |
 686 |     pub fn is_filled(&self) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1009:16
     |
1009 |         if let FillResult::Filled(order) = result {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `PartialFillResultOrError`
     |                |
     |                expected `PartialFillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::PartialFillResultOrError::Ok`
     |
1009 |         if let core::order_fsm::PartialFillResultOrError::Ok(FillResult::Filled(order)) = result {
     |                ++++++++++++++++++++++++++++++++++++++++++++++                         +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1023:16
     |
1023 |         if let FillResult::PartiallyFilled(order) = result {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `order_fsm::FillResultOrError`
     |                |
     |                expected `FillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
     |
1023 |         if let core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(order)) = result {
     |                +++++++++++++++++++++++++++++++++++++++                                  +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1029:20
     |
1029 |             if let FillResult::PartiallyFilled(order) = result {
     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `PartialFillResultOrError`
     |                    |
     |                    expected `PartialFillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::PartialFillResultOrError::Ok`
     |
1029 |             if let core::order_fsm::PartialFillResultOrError::Ok(FillResult::PartiallyFilled(order)) = result {
     |                    ++++++++++++++++++++++++++++++++++++++++++++++                                  +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1048:16
     |
1048 |         if let FillResult::PartiallyFilled(order) = result {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `order_fsm::FillResultOrError`
     |                |
     |                expected `FillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
     |
1048 |         if let core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(order)) = result {
     |                +++++++++++++++++++++++++++++++++++++++                                  +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1082:13
     |
1081 |         let order = match result {
     |                           ------ this expression has type `order_fsm::FillResultOrError`
1082 |             FillResult::PartiallyFilled(o) => o,
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
     |
1082 |             core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(o)) => o,
     |             +++++++++++++++++++++++++++++++++++++++                              +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1089:13
     |
1088 |         let order = match result {
     |                           ------ this expression has type `PartialFillResultOrError`
1089 |             FillResult::PartiallyFilled(o) => o,
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `PartialFillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::PartialFillResultOrError::Ok`
     |
1089 |             core::order_fsm::PartialFillResultOrError::Ok(FillResult::PartiallyFilled(o)) => o,
     |             ++++++++++++++++++++++++++++++++++++++++++++++                              +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1090:13
     |
1088 |         let order = match result {
     |                           ------ this expression has type `PartialFillResultOrError`
1089 |             FillResult::PartiallyFilled(o) => o,
1090 |             FillResult::Filled(o) => {
     |             ^^^^^^^^^^^^^^^^^^^^^ expected `PartialFillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::PartialFillResultOrError::Ok`
     |
1090 |             core::order_fsm::PartialFillResultOrError::Ok(FillResult::Filled(o)) => {
     |             ++++++++++++++++++++++++++++++++++++++++++++++                     +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1118:16
     |
1118 |         if let FillResult::Filled(order) = result {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `order_fsm::FillResultOrError`
     |                |
     |                expected `FillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
     |
1118 |         if let core::order_fsm::FillResultOrError::Ok(FillResult::Filled(order)) = result {
     |                +++++++++++++++++++++++++++++++++++++++                         +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1163:16
     |
1163 |         if let FillResult::PartiallyFilled(order) = result {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `order_fsm::FillResultOrError`
     |                |
     |                expected `FillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
     |
1163 |         if let core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(order)) = result {
     |                +++++++++++++++++++++++++++++++++++++++                                  +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1182:16
     |
1182 |         if let FillResult::PartiallyFilled(order) = result {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `order_fsm::FillResultOrError`
     |                |
     |                expected `FillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
     |
1182 |         if let core::order_fsm::FillResultOrError::Ok(FillResult::PartiallyFilled(order)) = result {
     |                +++++++++++++++++++++++++++++++++++++++                                  +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1195:16
     |
1195 |         if let FillResult::Filled(order) = result {
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^   ------ this expression has type `order_fsm::FillResultOrError`
     |                |
     |                expected `FillResultOrError`, found `FillResult`
     |
help: try wrapping the pattern in `core::order_fsm::FillResultOrError::Ok`
     |
1195 |         if let core::order_fsm::FillResultOrError::Ok(FillResult::Filled(order)) = result {
     |                +++++++++++++++++++++++++++++++++++++++                         +

error[E0308]: mismatched types
    --> bog-core/src/core/order_fsm.rs:1283:31
     |
1276 |           let mut current = FillResult::PartiallyFilled(OrderPartiallyFilled {
     |  ___________________________-
1277 | |             data: order.data,
1278 | |         });
     | |__________- expected due to this value
...
1283 |                       current = order.fill(fill_size, 50_000_000_000_000);
     |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FillResult`, found `PartialFillResultOrError`

error[E0277]: cannot subtract `{float}` from `u32`
   --> bog-core/src/data/types.rs:265:25
    |
265 |         assert!((spread - 1.0).abs() < 0.01);
    |                         ^ no implementation for `u32 - {float}`
    |
    = help: the trait `Sub<{float}>` is not implemented for `u32`
    = help: the following other types implement trait `Sub<Rhs>`:
              `&u32` implements `Sub<&num_bigint::bigint::BigInt>`
              `&u32` implements `Sub<&num_bigint::biguint::BigUint>`
              `&u32` implements `Sub<&num_complex::Complex<u32>>`
              `&u32` implements `Sub<num_bigint::bigint::BigInt>`
              `&u32` implements `Sub<num_bigint::biguint::BigUint>`
              `&u32` implements `Sub<num_complex::Complex<u32>>`
              `&u32` implements `Sub<u32>`
              `&u32` implements `Sub`
            and 9 others

error[E0609]: no field `max_age_ns` on type `validator::SnapshotValidator`
   --> bog-core/src/data/validator.rs:504:30
    |
504 |         assert_eq!(validator.max_age_ns, 5_000_000_000);
    |                              ^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
504 |         assert_eq!(validator.config.max_age_ns, 5_000_000_000);
    |                              +++++++

error[E0609]: no field `max_age_ns` on type `validator::SnapshotValidator`
   --> bog-core/src/data/validator.rs:510:30
    |
510 |         assert_eq!(validator.max_age_ns, 10_000_000_000);
    |                              ^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
510 |         assert_eq!(validator.config.max_age_ns, 10_000_000_000);
    |                              +++++++

error[E0308]: mismatched types
   --> bog-core/src/execution/lighter.rs:234:34
    |
234 |         let order = Order::limit(Side::Buy, dec!(50000), dec!(0.1));
    |                     ------------ ^^^^^^^^^ expected `execution::types::Side`, found `core::types::Side`
    |                     |
    |                     arguments to this function are incorrect
    |
    = note: `core::types::Side` and `execution::types::Side` have similar names, but are actually distinct types
note: `core::types::Side` is defined in module `crate::core::types` of the current crate
   --> bog-core/src/core/types.rs:121:1
    |
121 | pub enum Side {
    | ^^^^^^^^^^^^^
note: `execution::types::Side` is defined in module `crate::execution::types` of the current crate
   --> bog-core/src/execution/types.rs:49:1
    |
 49 | pub enum Side {
    | ^^^^^^^^^^^^^
note: associated function defined here
   --> bog-core/src/execution/types.rs:106:12
    |
106 |     pub fn limit(side: Side, price: Decimal, size: Decimal) -> Self {
    |            ^^^^^ ----------

error[E0308]: mismatched types
   --> bog-core/src/execution/lighter.rs:252:34
    |
252 |         let order = Order::limit(Side::Buy, dec!(50000), dec!(0.1));
    |                     ------------ ^^^^^^^^^ expected `execution::types::Side`, found `core::types::Side`
    |                     |
    |                     arguments to this function are incorrect
    |
    = note: `core::types::Side` and `execution::types::Side` have similar names, but are actually distinct types
note: `core::types::Side` is defined in module `crate::core::types` of the current crate
   --> bog-core/src/core/types.rs:121:1
    |
121 | pub enum Side {
    | ^^^^^^^^^^^^^
note: `execution::types::Side` is defined in module `crate::execution::types` of the current crate
   --> bog-core/src/execution/types.rs:49:1
    |
 49 | pub enum Side {
    | ^^^^^^^^^^^^^
note: associated function defined here
   --> bog-core/src/execution/types.rs:106:12
    |
106 |     pub fn limit(side: Side, price: Decimal, size: Decimal) -> Self {
    |            ^^^^^ ----------

error[E0308]: mismatched types
   --> bog-core/src/risk/circuit_breaker.rs:398:36
    |
398 |               exchange_timestamp_ns: SystemTime::now()
    |  ____________________________________^
399 | |                 .duration_since(UNIX_EPOCH)
400 | |                 .unwrap()
401 | |                 .as_nanos() as i64,
    | |__________________________________^ expected `u64`, found `i64`

error[E0277]: `fn(String) -> HaltReason {HaltReason::Manual}` doesn't implement `std::fmt::Display`
   --> bog-core/src/risk/circuit_breaker.rs:593:34
    |
593 |         assert_eq!(format!("{}", reason3), "Manual halt");
    |                             --   ^^^^^^^ `fn(String) -> HaltReason {HaltReason::Manual}` cannot be formatted with the default formatter
    |                             |
    |                             required by this formatting parameter
    |
   ::: bog-core/src/core/circuit_breaker_fsm.rs:79:5
    |
 79 |     Manual(String),
    |     ------ consider calling the constructor for `circuit_breaker_fsm::HaltReason::Manual`
    |
    = help: the trait `std::fmt::Display` is not implemented for fn item `fn(String) -> HaltReason {HaltReason::Manual}`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = help: use parentheses to construct this tuple variant: `circuit_breaker_fsm::HaltReason::Manual(/* std::string::String */)`
    = note: the full name for the type has been written to '/Users/vegtam/code/bog/target/release/deps/bog_core-fd0e342cc078d51c.long-type-14902035352533891731.txt'
    = note: consider using `--verbose` to print the full type name to the console
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no function or associated item named `new` found for struct `risk::RiskManager` in the current scope
   --> bog-core/src/risk/mod.rs:409:31
    |
 22 | pub struct RiskManager {
    | ---------------------- function or associated item `new` not found for this struct
...
409 |         let rm = RiskManager::new(&config);
    |                               ^^^ function or associated item not found in `risk::RiskManager`
    |
note: if you're trying to build a new `risk::RiskManager`, consider using `risk::RiskManager::with_limits` which returns `risk::RiskManager`
   --> bog-core/src/risk/mod.rs:34:5
    |
 34 |     pub fn with_limits(limits: RiskLimits) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `new`, perhaps you need to implement one of them:
            candidate #1: `UniformSampler`
            candidate #2: `brotli::enc::backward_references::hash_to_binary_tree::Allocable`
            candidate #3: `brotli::enc::threading::AnyBoxConstructor`
            candidate #4: `crypto_common::KeyInit`
            candidate #5: `crypto_common::KeyIvInit`
            candidate #6: `digest::VariableOutput`
            candidate #7: `digest::core_api::VariableOutputCore`
            candidate #8: `digest::digest::Digest`
            candidate #9: `parking_lot_core::thread_parker::ThreadParkerT`
            candidate #10: `parquet::column::reader::decoder::ColumnValueDecoder`
            candidate #11: `prometheus::core::Atomic`
            candidate #12: `protobuf::message::Message`
            candidate #13: `rand::distr::uniform::UniformSampler`
            candidate #14: `ring::aead::BoundKey`
            candidate #15: `simdutf8::basic::imp::ChunkedUtf8Validator`
            candidate #16: `simdutf8::basic::imp::Utf8Validator`
            candidate #17: `typenum::marker_traits::Bit`

error[E0599]: no function or associated item named `new` found for struct `risk::RiskManager` in the current scope
   --> bog-core/src/risk/mod.rs:418:31
    |
 22 | pub struct RiskManager {
    | ---------------------- function or associated item `new` not found for this struct
...
418 |         let rm = RiskManager::new(&config);
    |                               ^^^ function or associated item not found in `risk::RiskManager`
    |
note: if you're trying to build a new `risk::RiskManager`, consider using `risk::RiskManager::with_limits` which returns `risk::RiskManager`
   --> bog-core/src/risk/mod.rs:34:5
    |
 34 |     pub fn with_limits(limits: RiskLimits) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `new`, perhaps you need to implement one of them:
            candidate #1: `UniformSampler`
            candidate #2: `brotli::enc::backward_references::hash_to_binary_tree::Allocable`
            candidate #3: `brotli::enc::threading::AnyBoxConstructor`
            candidate #4: `crypto_common::KeyInit`
            candidate #5: `crypto_common::KeyIvInit`
            candidate #6: `digest::VariableOutput`
            candidate #7: `digest::core_api::VariableOutputCore`
            candidate #8: `digest::digest::Digest`
            candidate #9: `parking_lot_core::thread_parker::ThreadParkerT`
            candidate #10: `parquet::column::reader::decoder::ColumnValueDecoder`
            candidate #11: `prometheus::core::Atomic`
            candidate #12: `protobuf::message::Message`
            candidate #13: `rand::distr::uniform::UniformSampler`
            candidate #14: `ring::aead::BoundKey`
            candidate #15: `simdutf8::basic::imp::ChunkedUtf8Validator`
            candidate #16: `simdutf8::basic::imp::Utf8Validator`
            candidate #17: `typenum::marker_traits::Bit`

error[E0599]: no function or associated item named `new` found for struct `risk::RiskManager` in the current scope
   --> bog-core/src/risk/mod.rs:445:31
    |
 22 | pub struct RiskManager {
    | ---------------------- function or associated item `new` not found for this struct
...
445 |         let rm = RiskManager::new(&config);
    |                               ^^^ function or associated item not found in `risk::RiskManager`
    |
note: if you're trying to build a new `risk::RiskManager`, consider using `risk::RiskManager::with_limits` which returns `risk::RiskManager`
   --> bog-core/src/risk/mod.rs:34:5
    |
 34 |     pub fn with_limits(limits: RiskLimits) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `new`, perhaps you need to implement one of them:
            candidate #1: `UniformSampler`
            candidate #2: `brotli::enc::backward_references::hash_to_binary_tree::Allocable`
            candidate #3: `brotli::enc::threading::AnyBoxConstructor`
            candidate #4: `crypto_common::KeyInit`
            candidate #5: `crypto_common::KeyIvInit`
            candidate #6: `digest::VariableOutput`
            candidate #7: `digest::core_api::VariableOutputCore`
            candidate #8: `digest::digest::Digest`
            candidate #9: `parking_lot_core::thread_parker::ThreadParkerT`
            candidate #10: `parquet::column::reader::decoder::ColumnValueDecoder`
            candidate #11: `prometheus::core::Atomic`
            candidate #12: `protobuf::message::Message`
            candidate #13: `rand::distr::uniform::UniformSampler`
            candidate #14: `ring::aead::BoundKey`
            candidate #15: `simdutf8::basic::imp::ChunkedUtf8Validator`
            candidate #16: `simdutf8::basic::imp::Utf8Validator`
            candidate #17: `typenum::marker_traits::Bit`

error[E0599]: no function or associated item named `new` found for struct `risk::RiskManager` in the current scope
   --> bog-core/src/risk/mod.rs:465:35
    |
 22 | pub struct RiskManager {
    | ---------------------- function or associated item `new` not found for this struct
...
465 |         let mut rm = RiskManager::new(&config);
    |                                   ^^^ function or associated item not found in `risk::RiskManager`
    |
note: if you're trying to build a new `risk::RiskManager`, consider using `risk::RiskManager::with_limits` which returns `risk::RiskManager`
   --> bog-core/src/risk/mod.rs:34:5
    |
 34 |     pub fn with_limits(limits: RiskLimits) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `new`, perhaps you need to implement one of them:
            candidate #1: `UniformSampler`
            candidate #2: `brotli::enc::backward_references::hash_to_binary_tree::Allocable`
            candidate #3: `brotli::enc::threading::AnyBoxConstructor`
            candidate #4: `crypto_common::KeyInit`
            candidate #5: `crypto_common::KeyIvInit`
            candidate #6: `digest::VariableOutput`
            candidate #7: `digest::core_api::VariableOutputCore`
            candidate #8: `digest::digest::Digest`
            candidate #9: `parking_lot_core::thread_parker::ThreadParkerT`
            candidate #10: `parquet::column::reader::decoder::ColumnValueDecoder`
            candidate #11: `prometheus::core::Atomic`
            candidate #12: `protobuf::message::Message`
            candidate #13: `rand::distr::uniform::UniformSampler`
            candidate #14: `ring::aead::BoundKey`
            candidate #15: `simdutf8::basic::imp::ChunkedUtf8Validator`
            candidate #16: `simdutf8::basic::imp::Utf8Validator`
            candidate #17: `typenum::marker_traits::Bit`

error[E0599]: no function or associated item named `new` found for struct `risk::RiskManager` in the current scope
   --> bog-core/src/risk/mod.rs:498:31
    |
 22 | pub struct RiskManager {
    | ---------------------- function or associated item `new` not found for this struct
...
498 |         let rm = RiskManager::new(&config);
    |                               ^^^ function or associated item not found in `risk::RiskManager`
    |
note: if you're trying to build a new `risk::RiskManager`, consider using `risk::RiskManager::with_limits` which returns `risk::RiskManager`
   --> bog-core/src/risk/mod.rs:34:5
    |
 34 |     pub fn with_limits(limits: RiskLimits) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `new`, perhaps you need to implement one of them:
            candidate #1: `UniformSampler`
            candidate #2: `brotli::enc::backward_references::hash_to_binary_tree::Allocable`
            candidate #3: `brotli::enc::threading::AnyBoxConstructor`
            candidate #4: `crypto_common::KeyInit`
            candidate #5: `crypto_common::KeyIvInit`
            candidate #6: `digest::VariableOutput`
            candidate #7: `digest::core_api::VariableOutputCore`
            candidate #8: `digest::digest::Digest`
            candidate #9: `parking_lot_core::thread_parker::ThreadParkerT`
            candidate #10: `parquet::column::reader::decoder::ColumnValueDecoder`
            candidate #11: `prometheus::core::Atomic`
            candidate #12: `protobuf::message::Message`
            candidate #13: `rand::distr::uniform::UniformSampler`
            candidate #14: `ring::aead::BoundKey`
            candidate #15: `simdutf8::basic::imp::ChunkedUtf8Validator`
            candidate #16: `simdutf8::basic::imp::Utf8Validator`
            candidate #17: `typenum::marker_traits::Bit`

Some errors have detailed explanations: E0046, E0277, E0308, E0599, E0609.
For more information about an error, try `rustc --explain E0046`.
warning: `bog-core` (lib test) generated 5 warnings (4 duplicates)
error: could not compile `bog-core` (lib test) due to 36 previous errors; 5 warnings emitted
warning: build failed, waiting for other jobs to finish...
error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> bog-core/benches/engine_bench.rs:48:30
    |
 48 |             black_box(engine.process_tick(black_box(&snapshot)).unwrap());
    |                              ^^^^^^^^^^^^---------------------- argument #2 of type `bool` is missing
    |
note: method defined here
   --> /Users/vegtam/code/bog/bog-core/src/engine/generic.rs:329:12
    |
329 |     pub fn process_tick(&mut self, snapshot: &MarketSnapshot, data_fresh: bool) -> Result<()> {
    |            ^^^^^^^^^^^^
help: provide the argument
    |
 48 |             black_box(engine.process_tick(black_box(&snapshot), /* bool */).unwrap());
    |                                                               ++++++++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> bog-core/benches/engine_bench.rs:170:12
    |
170 |     engine.process_tick(&snapshot).unwrap();
    |            ^^^^^^^^^^^^----------- argument #2 of type `bool` is missing
    |
note: method defined here
   --> /Users/vegtam/code/bog/bog-core/src/engine/generic.rs:329:12
    |
329 |     pub fn process_tick(&mut self, snapshot: &MarketSnapshot, data_fresh: bool) -> Result<()> {
    |            ^^^^^^^^^^^^
help: provide the argument
    |
170 |     engine.process_tick(&snapshot, /* bool */).unwrap();
    |                                  ++++++++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> bog-core/benches/engine_bench.rs:175:30
    |
175 |             black_box(engine.process_tick(black_box(&snapshot)).unwrap());
    |                              ^^^^^^^^^^^^---------------------- argument #2 of type `bool` is missing
    |
note: method defined here
   --> /Users/vegtam/code/bog/bog-core/src/engine/generic.rs:329:12
    |
329 |     pub fn process_tick(&mut self, snapshot: &MarketSnapshot, data_fresh: bool) -> Result<()> {
    |            ^^^^^^^^^^^^
help: provide the argument
    |
175 |             black_box(engine.process_tick(black_box(&snapshot), /* bool */).unwrap());
    |                                                               ++++++++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> bog-core/benches/engine_bench.rs:227:30
    |
227 |             black_box(engine.process_tick(black_box(&snapshot)).unwrap());
    |                              ^^^^^^^^^^^^---------------------- argument #2 of type `bool` is missing
    |
note: method defined here
   --> /Users/vegtam/code/bog/bog-core/src/engine/generic.rs:329:12
    |
329 |     pub fn process_tick(&mut self, snapshot: &MarketSnapshot, data_fresh: bool) -> Result<()> {
    |            ^^^^^^^^^^^^
help: provide the argument
    |
227 |             black_box(engine.process_tick(black_box(&snapshot), /* bool */).unwrap());
    |                                                               ++++++++++++

For more information about this error, try `rustc --explain E0061`.
error: could not compile `bog-core` (bench "engine_bench") due to 4 previous errors
warning: `bog-strategies` (lib test) generated 4 warnings (2 duplicates)
warning: `bog-debug` (bin "orderbook-tui" test) generated 2 warnings (run `cargo fix --bin "orderbook-tui" --tests` to apply 1 suggestion)
