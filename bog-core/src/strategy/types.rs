use crate::execution::{Order, Side};
use rust_decimal::prelude::ToPrimitive;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};

/// Trading signal generated by a strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Signal {
    /// Place quotes on both sides
    QuoteBoth {
        bid_price: Decimal,
        ask_price: Decimal,
        size: Decimal,
    },
    /// Place a bid quote only
    QuoteBid { price: Decimal, size: Decimal },
    /// Place an ask quote only
    QuoteAsk { price: Decimal, size: Decimal },
    /// Cancel all quotes and go flat
    CancelAll,
    /// Take a market position (aggressive)
    TakePosition { side: Side, size: Decimal },
    /// No action
    NoAction,
}

impl Signal {
    /// Convert signal to orders
    pub fn to_orders(&self) -> Vec<Order> {
        match self {
            Signal::QuoteBoth {
                bid_price,
                ask_price,
                size,
            } => {
                vec![
                    Order::post_only(Side::Buy, *bid_price, *size),
                    Order::post_only(Side::Sell, *ask_price, *size),
                ]
            }
            Signal::QuoteBid { price, size } => {
                vec![Order::post_only(Side::Buy, *price, *size)]
            }
            Signal::QuoteAsk { price, size } => {
                vec![Order::post_only(Side::Sell, *price, *size)]
            }
            Signal::TakePosition { side, size } => {
                vec![Order::market(*side, *size)]
            }
            Signal::CancelAll | Signal::NoAction => vec![],
        }
    }

    /// Get net position change from this signal
    pub fn net_position_change(&self) -> Decimal {
        match self {
            Signal::QuoteBoth { .. } | Signal::QuoteBid { .. } | Signal::QuoteAsk { .. } => {
                // Market making orders are neutral (both sides cancel out conceptually)
                Decimal::ZERO
            }
            Signal::TakePosition { side, size } => match side {
                Side::Buy => *size,
                Side::Sell => -*size,
            },
            Signal::CancelAll | Signal::NoAction => Decimal::ZERO,
        }
    }

    /// Get total order size from this signal
    pub fn total_size(&self) -> Decimal {
        match self {
            Signal::QuoteBoth { size, .. } => *size * Decimal::from(2), // Both sides
            Signal::QuoteBid { size, .. } | Signal::QuoteAsk { size, .. } => *size,
            Signal::TakePosition { size, .. } => *size,
            Signal::CancelAll | Signal::NoAction => Decimal::ZERO,
        }
    }

    /// Check if signal requires action
    pub fn requires_action(&self) -> bool {
        !matches!(self, Signal::NoAction)
    }
}

/// Quote information
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct Quote {
    pub bid_price: Decimal,
    pub bid_size: Decimal,
    pub ask_price: Decimal,
    pub ask_size: Decimal,
}

impl Quote {
    pub fn new(
        bid_price: Decimal,
        bid_size: Decimal,
        ask_price: Decimal,
        ask_size: Decimal,
    ) -> Self {
        Self {
            bid_price,
            bid_size,
            ask_price,
            ask_size,
        }
    }

    pub fn mid_price(&self) -> Decimal {
        (self.bid_price + self.ask_price) / Decimal::from(2)
    }

    pub fn spread(&self) -> Decimal {
        self.ask_price - self.bid_price
    }

    pub fn spread_bps(&self) -> f64 {
        if self.bid_price > Decimal::ZERO {
            ((self.spread() / self.bid_price) * Decimal::from(10000))
                .to_f64()
                .unwrap_or(0.0)
        } else {
            0.0
        }
    }
}

/// Strategy state
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum StrategyState {
    /// Strategy is initializing
    Initializing,
    /// Strategy is actively trading
    Active,
    /// Strategy is paused (no new orders)
    Paused,
    /// Strategy is stopped
    Stopped,
}

#[cfg(test)]
mod tests {
    use super::*;
    use rust_decimal_macros::dec;

    #[test]
    fn test_signal_to_orders() {
        let signal = Signal::QuoteBoth {
            bid_price: dec!(50000),
            ask_price: dec!(50010),
            size: dec!(0.1),
        };

        let orders = signal.to_orders();
        assert_eq!(orders.len(), 2);
        assert_eq!(orders[0].side, Side::Buy);
        assert_eq!(orders[1].side, Side::Sell);
    }

    #[test]
    fn test_signal_position_change() {
        let buy_signal = Signal::TakePosition {
            side: Side::Buy,
            size: dec!(0.5),
        };
        assert_eq!(buy_signal.net_position_change(), dec!(0.5));

        let sell_signal = Signal::TakePosition {
            side: Side::Sell,
            size: dec!(0.3),
        };
        assert_eq!(sell_signal.net_position_change(), dec!(-0.3));

        let quote_signal = Signal::QuoteBoth {
            bid_price: dec!(50000),
            ask_price: dec!(50010),
            size: dec!(0.1),
        };
        assert_eq!(quote_signal.net_position_change(), Decimal::ZERO);
    }

    #[test]
    fn test_signal_total_size() {
        let both = Signal::QuoteBoth {
            bid_price: dec!(50000),
            ask_price: dec!(50010),
            size: dec!(0.1),
        };
        assert_eq!(both.total_size(), dec!(0.2)); // Both sides

        let bid = Signal::QuoteBid {
            price: dec!(50000),
            size: dec!(0.1),
        };
        assert_eq!(bid.total_size(), dec!(0.1));

        let no_action = Signal::NoAction;
        assert_eq!(no_action.total_size(), Decimal::ZERO);
    }

    #[test]
    fn test_quote() {
        let quote = Quote::new(dec!(50000), dec!(1.0), dec!(50010), dec!(1.5));

        assert_eq!(quote.mid_price(), dec!(50005));
        assert_eq!(quote.spread(), dec!(10));

        let spread_bps = quote.spread_bps();
        assert!((spread_bps - 2.0).abs() < 0.01); // 10/50000 * 10000 = 2 bps
    }

    #[test]
    fn test_signal_requires_action() {
        assert!(Signal::QuoteBoth {
            bid_price: dec!(50000),
            ask_price: dec!(50010),
            size: dec!(0.1)
        }
        .requires_action());

        assert!(!Signal::NoAction.requires_action());
    }
}
